from abc import ABCMeta, abstractmethod
from bci_framework.api.utils import WebSocket
import json
import os
from browser import timer, html, document
from datetime import datetime
from functools import wraps

import random

StimuliServer = None


########################################################################
class DeliveryInstance_:
    """"""

    # ----------------------------------------------------------------------
    @classmethod
    def both(cls, method):
        """Decorator for execute method in both environs, dashboard and delivery."""

        def wrap(self, *args, **kwargs):

            if self._bci_mode in ['development', 'dashboard']:
                print('Calling', method.__name__, args, kwargs)
                method(self, *args, **kwargs)

                self.ws.send({'action': 'feed',
                              'method': method.__name__,
                              'args': list(args),  # prevent ellipsis objects
                              'kwargs': dict(kwargs),
                              })
                print('Called!!')

        wrap.no_decorator = method
        return wrap

    # ----------------------------------------------------------------------
    @classmethod
    def remote(cls, method):
        """Decorator for execute methon only in delivery environ."""

        def wrap(self, *args, **kwargs):

            if self._bci_mode in ['development', 'dashboard']:
                print('Calling', method.__name__, args, kwargs)
                # method(self, *args, **kwargs)  # no local
                self.ws.send({'action': 'feed',
                              'method': method.__name__,
                              'args': list(args),  # prevent ellipsis objects
                              'kwargs': dict(kwargs),
                              })
                print('Called!!')

        wrap.no_decorator = method
        return wrap

    # # ----------------------------------------------------------------------
    # @classmethod
    # def propagate(cls, argument):
        # def inner_function(method):
            # @wraps(method)
            # def wrap(self, *args, **kwargs):

                # if self._bci_mode in ['development', 'dashboard']:
                    # print('Calling', method.__name__, args, kwargs)
                    # method(self, *args, **kwargs)

                    # print(argument, getattr(self, argument))

                    # self.ws.send({'action': 'feed',
                                  # 'method': method.__name__,
                                  # 'args': list(args),  # prevent ellipsis objects
                                  # 'kwargs': dict(kwargs),
                                  # })
                    # print('Called!!')

            # wrap.no_decorator = method
            # return wrap
        # return inner_function


DeliveryInstance = DeliveryInstance_()


########################################################################
class BCIWebSocket(WebSocket):
    """"""

    # ----------------------------------------------------------------------
    def on_open(self, evt):
        """"""
        print('Opened')
        self.send({'action': 'register'})

    # ----------------------------------------------------------------------
    def on_message(self, evt):
        """"""
        data = json.loads(evt.data)
        print("MESSAGE", data, self.main)
        if 'method' in data:
            getattr(self.main, data['method']).no_decorator(
                self.main, *data['args'], **data['kwargs'])

    # ----------------------------------------------------------------------
    def on_close(self, evt):
        """"""
        getattr(self.main, 'stop', lambda: None)()
        print('Closed WS')
        timer.set_timeout(lambda: self.__init__(
            f'ws://localhost:{self.ip_}/ws'), 1000)

    # # ----------------------------------------------------------------------
    # def on_error(self, evt):
        # """"""
        # self.main.stop()
        # print('Error WS')
        # self.__init__(self.ip)


########################################################################
class StimuliAPI(metaclass=ABCMeta):
    """"""

    # ----------------------------------------------------------------------
    def connect(self, ip=5000):
        """"""
        self.ws = BCIWebSocket(f'ws://localhost:{ip}/ws')
        self.ws.main = self

    # # ----------------------------------------------------------------------
    # @abstractmethod
    # def start(self):
        # """"""

    # # ----------------------------------------------------------------------
    # @abstractmethod
    # def stop(self):
        # """"""

    # ----------------------------------------------------------------------
    # @delivery
    def send_marker(self, marker):
        """"""

        marker = {
            'marker': marker,
            'datetime': datetime.now().timestamp(),
        }

        print(f'MARKER: {marker["marker"]}')
        self.ws.send({
            'action': 'marker',
            'marker': marker,
        })

        # self.ws.send({'action': 'feed',
                      # 'method': 'method.__name__',
                      # 'args': ['args'],
                      # 'kwargs': {'kwargs': '5', },
                      # })

    # ----------------------------------------------------------------------
    def add_stylesheet(self, file):
        """"""
        document.select('head')[0] <= html.LINK(
            href=os.path.join('root', file), type='text/css', rel='stylesheet')

    # ----------------------------------------------------------------------
    @property
    def dashboard(self):
        """"""
        if not hasattr(self, 'bci_dashboard'):
            self.bci_dashboard = html.DIV(Class='bci_dashboard')
            document <= self.bci_dashboard
        return self.bci_dashboard

    # ----------------------------------------------------------------------
    @property
    def stimuli_area(self):
        """"""
        if not hasattr(self, 'bci_stimuli'):
            self.bci_stimuli = html.DIV(Class='bci_stimuli')
            document <= self.bci_stimuli
        return self.bci_stimuli

    # ----------------------------------------------------------------------
    @DeliveryInstance.remote
    def set_seed(self, seed):
        """"""
        random.seed(seed)
        print(f"SEED: {seed}")

    # ----------------------------------------------------------------------
    def propagate_seed(self):
        """"""
        seed = random.randint(0, 99999)
        self.set_seed(seed)










